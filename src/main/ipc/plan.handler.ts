/**
 * Plan Execution IPC Handlers — Sprint 5 full implementation.
 *
 * Responsibilities:
 * - Store parsed plans by ID (in-memory Map, one per session)
 * - Start/pause/resume/cancel plan execution
 * - Bridge the approval dialog (main↔renderer round-trip)
 * - Forward PlanEvents to renderer
 * - Mirror step output to the terminal panel (ssh:data channel)
 */

import { ipcMain, BrowserWindow } from 'electron';
import { IPC_CHANNELS } from '@shared/constants';
import { PlanExecutor } from '../services/execution/PlanExecutor';
import { CommandExecutor, SSHExecutor } from '../services/execution/CommandExecutor';
import { ApprovalHandler } from '../services/execution/StepExecutor';
import { sshManager } from '../services/ssh/SSHManager';
import type { PlanEvent } from '@shared/types/execution';
import type { ExecutionPlan, ActiveConnection, OSInfo } from '@shared/types';

// ── Module-level state ─────────────────────────────────────────────────────

/** Plans stored by ID between generation and execution (in-memory, MVP scope) */
const planStore = new Map<string, ExecutionPlan>();

/** Connection context needed by the executor */
let activeConnectionContext: {
  connection: ActiveConnection;
  osInfo: OSInfo;
  connectionId: string;
} | null = null;

let activePlanExecutor: PlanExecutor | null = null;

/** Resolves the pending approval promise when the user responds */
let pendingApprovalResolve: ((decision: 'approve' | 'reject' | 'skip') => void) | null = null;

// ── Helpers ────────────────────────────────────────────────────────────────

function makeSSHExecutor(): SSHExecutor {
  return {
    async executeCommand(command: string) {
      const result = await sshManager.executeCommand(command);
      return {
        stdout: result.stdout,
        stderr: result.stderr,
        exitCode: result.code, // SSHCommandResult uses .code; CommandExecutor uses .exitCode
      };
    },
  };
}

// ── Handler registration ───────────────────────────────────────────────────

export function registerPlanHandlers(mainWindow: BrowserWindow): void {
  function send(channel: string, ...args: unknown[]): void {
    if (!mainWindow.isDestroyed()) {
      mainWindow.webContents.send(channel, ...args);
    }
  }

  // ── Store plan when generated by AI ─────────────────────────────────────
  // AIOrchestrator already sends PLAN.GENERATED to the renderer.
  // We also listen here on the main side to cache the plan for execution lookup.
  ipcMain.on(IPC_CHANNELS.PLAN.GENERATED, (_event, plan: ExecutionPlan) => {
    planStore.set(plan.id, plan);
    console.log(`[Plan] Stored plan ${plan.id} — "${plan.goal}" (${plan.steps.length} steps)`);
  });

  // ── Execute plan ─────────────────────────────────────────────────────────
  ipcMain.handle(IPC_CHANNELS.PLAN.EXECUTE, async (_event, planId: string, mode?: import('@shared/types').ExecutionMode) => {
    const plan = planStore.get(planId);
    if (!plan) {
      throw new Error(`Plan ${planId} not found. It may have expired.`);
    }

    if (!sshManager.isConnected()) {
      throw new Error('No active SSH connection');
    }

    if (!activeConnectionContext) {
      throw new Error('Connection context not available. Please reconnect.');
    }

    if (activePlanExecutor) {
      throw new Error('A plan is already executing. Cancel it before starting a new one.');
    }

    const approvalHandler: ApprovalHandler = {
      requestApproval(stepId, command, riskLevel, warningMessage): Promise<'approve' | 'reject' | 'skip'> {
        return new Promise((resolve) => {
          pendingApprovalResolve = resolve;
          send(IPC_CHANNELS.PLAN.APPROVAL_NEEDED, { stepId, command, riskLevel, warningMessage });
        });
      },
    };

    const commandExecutor = new CommandExecutor(makeSSHExecutor());
    activePlanExecutor = new PlanExecutor(commandExecutor, approvalHandler);

    const { connection, osInfo, connectionId } = activeConnectionContext;
    // Execution-time mode takes precedence over the mode stored on the plan
    const executionMode: import('@shared/types').ExecutionMode = mode ?? (plan as any).mode ?? 'planner';

    // Run executor in the background — IPC handle returns immediately
    (async () => {
      if (!activePlanExecutor) return;
      try {
        for await (const event of activePlanExecutor.execute(plan, {
          connection, osInfo, mode: executionMode, connectionId,
        })) {
          send(IPC_CHANNELS.PLAN.EVENT, event);

          // Mirror command output to the xterm terminal panel
          if (event.type === 'step-completed' || event.type === 'step-failed') {
            const result = event.result;
            // exec() channel output uses bare \n — normalise to \r\n
            // so xterm.js moves the cursor to column 0 on each new line.
            const normLF = (s: string) => s.replace(/\r\n/g, '\n').replace(/\n/g, '\r\n');
            // Filter noisy informational warnings that clutter the terminal
            const filterStderr = (s: string) => s
              .split('\n')
              .filter(line => !/WARNING: apt does not have a stable CLI interface/i.test(line))
              .join('\n');
            if (result.stdout) send(IPC_CHANNELS.SSH.DATA, normLF(result.stdout));
            if (result.stderr) {
              const cleaned = filterStderr(result.stderr).trim();
              if (cleaned) send(IPC_CHANNELS.SSH.DATA, `\x1b[33m${normLF(cleaned)}\x1b[0m`);
            }
          }

          if (event.type === 'plan-completed' || event.type === 'plan-cancelled') {
            activePlanExecutor = null;
            // Return terminal to a command prompt so it doesn't end on a blank line
            send(IPC_CHANNELS.SSH.DATA, '\r\n$ ');
          }
        }
      } catch (err) {
        const reason = err instanceof Error ? err.message : String(err);
        send(IPC_CHANNELS.PLAN.EVENT, {
          type: 'plan-cancelled',
          reason,
          completedSteps: 0,
        } as PlanEvent);
        activePlanExecutor = null;
      }
    })();

    return { success: true };
  });

  // ── Approval response from renderer ──────────────────────────────────────
  ipcMain.on(
    IPC_CHANNELS.PLAN.APPROVAL_RESPONSE,
    (_event, payload: { decision: 'approve' | 'reject' | 'skip' }) => {
      if (pendingApprovalResolve) {
        pendingApprovalResolve(payload.decision);
        pendingApprovalResolve = null;
      }
    },
  );

  // ── Pause ─────────────────────────────────────────────────────────────────
  ipcMain.on(IPC_CHANNELS.PLAN.PAUSE, () => {
    activePlanExecutor?.pause();
    console.log('[Plan] Paused');
  });

  // ── Resume ────────────────────────────────────────────────────────────────
  ipcMain.on(IPC_CHANNELS.PLAN.RESUME, () => {
    activePlanExecutor?.resume();
    console.log('[Plan] Resumed');
  });

  // ── Cancel ────────────────────────────────────────────────────────────────
  ipcMain.on(IPC_CHANNELS.PLAN.CANCEL, () => {
    if (activePlanExecutor) {
      activePlanExecutor.cancel();
      activePlanExecutor = null;
    }
    if (pendingApprovalResolve) {
      pendingApprovalResolve('reject');
      pendingApprovalResolve = null;
    }
    console.log('[Plan] Cancelled');
  });

  console.log('[IPC] Plan handlers registered');
}

// ── Public helpers used by other modules ──────────────────────────────────

/**
 * Called by ssh.handler.ts after a successful connection so the plan executor
 * has the ActiveConnection + OSInfo it needs without going through the renderer.
 */
export function setPlanConnectionContext(ctx: {
  connection: ActiveConnection;
  osInfo: OSInfo;
  connectionId: string;
}): void {
  activeConnectionContext = ctx;
}

/**
 * Called by AIOrchestrator (main process) to register a plan immediately
 * when it is created, before the PLAN.GENERATED IPC event fires.
 */
export function storePlan(plan: ExecutionPlan): void {
  planStore.set(plan.id, plan);
}

