/**
 * PlanMutator — pure functions for safe, immutable plan modification.
 *
 * The Agentic Loop needs to splice new repair steps into a running plan
 * without breaking the step ID uniqueness, index ordering, or the IPC
 * contract (the renderer re-renders from the full plan object).
 *
 * Rules:
 *  - NEVER mutate the input plan — always return a new object
 *  - Always assign unique IDs to new steps (agent-<timestamp>-<n>)
 *  - Always recalculate step.index for ALL steps after the splice point
 *  - Enforce a total plan size ceiling (original length + MAX_ADDED_STEPS)
 */

import type { ExecutionPlan, PlanStep, RiskAssessment } from '@shared/types';
import type { ProtoStep } from '@shared/types/execution';
import { riskClassifier } from '../security/RiskClassifier';

// ── Constants ──────────────────────────────────────────────────────────────

/** Hard cap on how many extra steps an agent loop may add to a plan */
export const MAX_ADDED_STEPS = 10;

// ── ID generation ──────────────────────────────────────────────────────────

let _idCounter = 0;

function generateAgentStepId(): string {
  _idCounter = (_idCounter + 1) % 10_000;
  return `agent-${Date.now()}-${_idCounter}`;
}

// ── ProtoStep → PlanStep promotion ────────────────────────────────────────

/**
 * Promotes an AI-generated ProtoStep into a full PlanStep.
 *
 * Uses RiskClassifier to produce a proper RiskAssessment from the command
 * (the agent may under-report risk; the classifier provides the ground truth).
 */
function promoteProtoStep(proto: ProtoStep, index: number): PlanStep {
  const classifiedRisk = riskClassifier.classifyCommand(proto.command);

  // Use the stricter of the two risk levels
  const levels = ['safe', 'caution', 'dangerous', 'blocked'] as const;
  const agentIdx  = levels.indexOf(proto.riskLevel);
  const classIdx  = levels.indexOf(classifiedRisk.level);
  const effectiveLevel = classIdx >= agentIdx ? classifiedRisk.level : proto.riskLevel;

  const riskAssessment: RiskAssessment = {
    level: effectiveLevel,
    category: classifiedRisk.category || 'agent-generated',
    reason: classifiedRisk.reason || proto.explanation || 'Generated by agent repair step',
    requiresApproval: effectiveLevel === 'dangerous' || effectiveLevel === 'blocked',
    warningMessage: classifiedRisk.warningMessage,
  };

  return {
    id: generateAgentStepId(),
    index,
    description: proto.description,
    command: proto.command,
    riskAssessment,
    status: 'pending',
    explanation: proto.explanation,
    expectedOutput: proto.expectedOutput,
  };
}

// ── Re-index helper ────────────────────────────────────────────────────────

/**
 * Returns a new steps array with step.index equal to the position in the array.
 * Must be called any time the steps array changes.
 */
function reindex(steps: PlanStep[]): PlanStep[] {
  return steps.map((s, i) => s.index === i ? s : { ...s, index: i });
}

// ── Public API ─────────────────────────────────────────────────────────────

/**
 * Insert one or more repair steps immediately after the step with `afterStepId`.
 *
 * If the insertion would push the plan beyond the size ceiling, as many new
 * steps as the budget allows are inserted and the rest are silently dropped.
 *
 * Returns the mutated plan (new object) and the number of steps actually inserted.
 */
export function insertSteps(
  plan: ExecutionPlan,
  afterStepId: string,
  protoSteps: ProtoStep[],
): { plan: ExecutionPlan; inserted: number } {
  const insertAfterIdx = plan.steps.findIndex(s => s.id === afterStepId);
  if (insertAfterIdx === -1) {
    console.warn(`[PlanMutator] insertSteps: step "${afterStepId}" not found — skipping`);
    return { plan, inserted: 0 };
  }

  // How many slots remain in the budget?
  const originalLength = (plan as ExecutionPlan & { _originalLength?: number })._originalLength
    ?? plan.steps.length;
  const maxTotal = originalLength + MAX_ADDED_STEPS;
  const available = Math.max(0, maxTotal - plan.steps.length);
  const toInsert = protoSteps.slice(0, available);

  if (toInsert.length === 0) {
    return { plan, inserted: 0 };
  }

  // Promote ProtoSteps → PlanSteps with provisional indices (will be reindexed)
  const newPlanSteps = toInsert.map((p, i) =>
    promoteProtoStep(p, insertAfterIdx + 1 + i),
  );

  const updatedSteps = reindex([
    ...plan.steps.slice(0, insertAfterIdx + 1),
    ...newPlanSteps,
    ...plan.steps.slice(insertAfterIdx + 1),
  ]);

  const updatedPlan: ExecutionPlan = {
    ...plan,
    steps: updatedSteps,
  };

  // Preserve original length for budget tracking
  (updatedPlan as ExecutionPlan & { _originalLength?: number })._originalLength = originalLength;

  return { plan: updatedPlan, inserted: toInsert.length };
}

/**
 * Insert one or more repair steps immediately BEFORE the step with `beforeStepId`.
 *
 * The typical use case: insert prerequisites (unlock apt, create a directory, etc.)
 * before a failed step so it can be retried after the repair steps succeed.
 *
 * Returns the mutated plan (new object) and the number of steps actually inserted.
 */
export function insertStepsBefore(
  plan: ExecutionPlan,
  beforeStepId: string,
  protoSteps: ProtoStep[],
): { plan: ExecutionPlan; inserted: number } {
  const insertBeforeIdx = plan.steps.findIndex(s => s.id === beforeStepId);
  if (insertBeforeIdx === -1) {
    console.warn(`[PlanMutator] insertStepsBefore: step "${beforeStepId}" not found — skipping`);
    return { plan, inserted: 0 };
  }

  const originalLength = (plan as ExecutionPlan & { _originalLength?: number })._originalLength
    ?? plan.steps.length;
  const maxTotal = originalLength + MAX_ADDED_STEPS;
  const available = Math.max(0, maxTotal - plan.steps.length);
  const toInsert = protoSteps.slice(0, available);

  if (toInsert.length === 0) {
    return { plan, inserted: 0 };
  }

  const newPlanSteps = toInsert.map((p, i) =>
    promoteProtoStep(p, insertBeforeIdx + i),
  );

  const updatedSteps = reindex([
    ...plan.steps.slice(0, insertBeforeIdx),
    ...newPlanSteps,
    ...plan.steps.slice(insertBeforeIdx),
  ]);

  const updatedPlan: ExecutionPlan = { ...plan, steps: updatedSteps };
  (updatedPlan as ExecutionPlan & { _originalLength?: number })._originalLength = originalLength;
  return { plan: updatedPlan, inserted: toInsert.length };
}

/**
 * Replace the command of an existing step (for simple fix-and-retry).
 * The step's description, risk assessment, and status are all updated.
 *
 * Returns the mutated plan (new object).
 */
export function replaceStepCommand(
  plan: ExecutionPlan,
  stepId: string,
  newCommand: string,
): ExecutionPlan {
  const idx = plan.steps.findIndex(s => s.id === stepId);
  if (idx === -1) {
    console.warn(`[PlanMutator] replaceStepCommand: step "${stepId}" not found`);
    return plan;
  }

  const originalStep = plan.steps[idx];
  const classifiedRisk = riskClassifier.classifyCommand(newCommand);

  const updatedStep: PlanStep = {
    ...originalStep,
    command: newCommand,
    riskAssessment: {
      level: classifiedRisk.level,
      category: classifiedRisk.category || originalStep.riskAssessment.category,
      reason: classifiedRisk.reason || originalStep.riskAssessment.reason,
      requiresApproval: classifiedRisk.level === 'dangerous' || classifiedRisk.level === 'blocked',
      warningMessage: classifiedRisk.warningMessage,
    },
    status: 'pending', // reset status so it can be re-executed
  };

  const updatedSteps = [...plan.steps];
  updatedSteps[idx] = updatedStep;

  return { ...plan, steps: updatedSteps };
}
